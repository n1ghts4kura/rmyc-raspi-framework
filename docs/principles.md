# 项目通用原则（Principles）

> 本文档总结本项目在文档编写、代码编写、测试与项目管理中的**共通原则**。
> 这些原则是从当前代码结构、文档约定（如 `copilot-instructions.md`、`index.md`、`status.md`）以及整体工程实践中抽象出来的，用于指导后续开发与按需文档生成。

---

## 0. 文档同步原则 (Documentation Synchronization Principle)

**LLMs**在进行项目开发进程中，需要将**文档更新**视为与代码变更同等重要的任务。
无论改动大小，都应该**思考**是否需要更新以下文档**：

- `docs/status.md`：同步当前状态、已知问题；
- `docs/index.md`：新增或调整核心入口文档的链接与摘要；
- `docs/plans.md`： 如与计划中的内容有出入，**必须**询问维护者是否需要更新；
- `docs/principles.md`：如发现当前原则与自我行为**冲突**，**必须**向维护者报告，并询问改进措施以减少冲突发生；
- `docs/*.md`：如涉及架构、模块、功能的变更，**必须**检查是否需要更新对应的 `*_intro.md` 或 `*_journey.md` 文档。

---

## 1. 文档编写原则（Documentation Principles）

1. **骨架先行，细节按需**  
   - 先建立清晰的文档骨架（`index.md`、`status.md`、`*_intro.md`、`*_journey.md`），保证导航与状态可信；  
   - 详细内容可以在需要时通过 LLM 辅助生成并逐步补齐，而不是一开始就试图写完所有细节。

2. **文档同时服务人类与 LLM**  
   - 所有 `.md` 文档默认既面向人类开发者，也面向 LLM，不再区分 “for AI” 与 “for human”；  
   - 结构上力求清晰、分节明确，适合被 LLM 解析成事实与上下文。

3. **命名规范统一、可预测**  
   - 架构 / 模块说明：使用 `xxx_intro.md` 或明显的模块名（如 `general_intro.md`、`aimassistant_intro.md`）；  
   - 设计历程与决策：统一收敛到 `*_journey.md`，不再使用单独的 `*_decision_journey.md`；  
   - 操作 / 使用说明：使用直观的名字（如 `repl.md`、`status.md`、`troubleshooting.md`）。

4. **事实与决策分层，但彼此有链路**  
   - 技术说明文档（`*_intro.md`）以“当前事实”为主，描述架构、数据流、接口；  
   - Journey 文档（`*_journey.md`）记录演进过程、失败方案、性能对比和决策理由；  
   - 在说明文档中可以链接到对应的 Journey 文档，避免在一个文档里混杂过多历史细节。

5. **状态文档要真实、简短、可维护**  
   - `status.md` 只聚焦“当前状态”：版本阶段、子系统完成度、测试验证程度、已知问题、短期计划；  
   - 通过 `_TODO` 占位符、简短 bullet 列表等方式，降低维护心智负担；  
   - 当状态变化较大时优先更新 `status.md`，让它成为所有文档与 LLM 的“现实基线”。

6. **文档更新与代码变更强绑定**  
   - 发生架构调整、新模块开发、核心算法变更或重要 bug 修复时，优先思考是否需要：  
     - 更新对应的 `*_intro.md`；  
     - 为该模块新增或补充 `*_journey.md` 条目；  
     - 在 `status.md` 中同步当前影响范围与风险；  
   - 将“代码变更 → 文档同步”视作一个完整动作，而不是后置补课。

7. **使用 REPL 与工具脚本作为文档的配套说明**  
   - 面向硬件操作与调试场景，优先通过 `repl.md`、工具脚本说明等文档提供“可复制”的操作步骤；  
   - 文档中的命令示例应可以直接在 REPL 或 shell 中运行，减少解释与猜测。

8. **文档类别与职责清晰划分**  

- Control / Navigation 类文档（如 `index.md`、`general_intro.md`、`status.md`、`plans.md`、`principles.md`）只负责整体视图、原则、状态与计划，不承载模块细节或实验日志；  
- Intro 类文档（如未来的 `aimassistant_intro.md`、`recognizer_intro.md`）只负责说明某个模块当前的职责、接口与数据流，不混入调试过程；  
- Journey / History 文档（如 `v1_0_history.md`、`aimassistant_journey.md`、`performance_journey.md`）专门记录演进过程、踩坑、决策与实验结果；  
- Reference 文档（如 `reference/sdk_protocol_api_document.md`）承载长期稳定的事实性信息（协议、参数、规则）；  
- Guide / Ops 文档（如 `repl.md`）聚焦「如何做某事」的步骤与注意事项。

9. **命名与放置遵循统一结构**  

- 模块介绍文档统一使用 `<module_name>_intro.md` 命名，推荐放在 `docs/module/`（当前可以先放在 `docs/` 顶层）；  
- 主题演进文档统一使用 `<topic>_journey.md` 命名，版本级历史使用 `<version>_history.md` 命名，统一放在 `docs/journey/`；  
- 参考文档统一放在 `docs/reference/`，命名为 `<topic>_reference.md` 或 `<topic>_document.md`；  
- 不再使用 `*_for_ai.md`、`*_intro_for_ai_legacy.md`、`*_decision_history.md` 等旧命名形式，所有文档默认同时服务人类和 LLM。

10. **历史文档结构与 YAML 头部保持一致**  

- 所有 `docs/journey/*.md` 建议使用统一的 YAML 头部，至少包含：`title`、`version`、`status`、`category`（固定为 `journey`）、`history_scope`、`history_period`、`history_tags`；  
- 推荐额外添加：`maintainers`、`last_updated`、`llm_summary`、`llm_entry_points`，以便快速筛选和检索；  
- Journey 正文推荐采用统一骨架：时间线与阶段 → 问题/分析/解决 → 决策与权衡 → 实验数据 → 经验教训 → 附录。

11. **控制层信息集中维护，Journey 只引用不复写**  

- 设计原则与协作约定集中写在 `principles.md`；当前项目状态与子系统完成度集中写在 `status.md`；版本路线与里程碑集中写在 `plans.md`；  
- Journey 文档在需要引用这些信息时，应以「链接 + 简短引用」的方式，而不是在各自正文中重新维护一套独立描述，避免产生多份不一致的“真相来源”。

12. **旧文档目录视作冷存档素材仓**  

- `old_docs/documents/` 仅作为旧版长日志与完整记录的存放处，新内容一律写入 `docs/` 下的新体系（如 `docs/journey/*.md`、`docs/reference/*.md`）；  
- 从旧文档迁移历史信息时，应在新 Journey 中做压缩复盘，并通过附录或链接指向旧文档原文，而不是简单复制粘贴；  
- 在确认某个主题的关键信息已在新文档中完整承接后，可以考虑删除对应旧文档，仅保留在 git 历史中以备极端情况下查阅。

---

## 2. 代码编写原则（Code Writing Principles）

1. **清晰的分层与职责单一**  
   - `src/bot/` 负责硬件抽象与 SDK 协议封装；  
   - `src/aimassistant/` 负责自瞄算法与管线逻辑；  
   - `src/skill/` 负责技能管理与业务行为组合；  
   - `src/recognizer.py` 负责模型加载与推理入口；  
   - 其他模块（如 `config.py`、`logger.py`、`utils.py`）提供横切支持能力。  
   > 原则：模块内部可以复杂，但模块之间的接口与依赖关系要尽量简单、方向明确。

2. **统一命名与类型标注**  
   - 函数使用 `verb_noun` 风格（如 `set_chassis_speed_3d`、`move_gimbal`）；  
   - 变量使用 `lowercase_underscore`；私有成员使用 `_` 前缀；常量使用 `UPPERCASE_UNDERSCORE`；  
   - 公共函数必须添加类型注解（`typing`），保证 LLM 与 IDE 补全的准确性。

3. **硬件控制必须校验参数范围**  
   - 所有直接作用于底盘、云台、发射器的 API，必须在函数入口处进行参数范围校验；  
   - 在 docstring 中说明范围与含义（例如速度范围、角度限制、单位）；  
   - 超出范围时宁可抛出明确异常，也不要默默裁剪或忽略。

4. **日志与错误信息要可读、可排查**  
   - 使用统一的日志模块（`logger.py`）输出关键信息，避免直接 `print`；  
   - 日志内容应包含：操作对象、关键参数与异常原因，便于快速从日志回溯问题；  
   - 对外暴露的异常信息尽量友好，同时在日志中保留足够技术细节。

5. **在写新工具/通用函数前先看 `utils.py`**  
   - 项目中通用的工具函数应优先集中在 `src/utils.py` 内，以避免重复造轮子；  
   - 新增工具函数前先检查是否已有类似功能；若是泛用能力，则补充到 `utils.py`；  
   - 模块专用的工具逻辑则保留在模块内部，避免 `utils.py` 变成“万能垃圾桶”。

6. **保持与目标运行环境兼容**  
   - 开发环境是 Windows，但目标运行环境是 Raspberry Pi（Linux）：  
     - 使用 Linux 风格路径（如 `/dev/ttyUSB0`），避免硬编码 `C:\` 或 `COM3`；  
     - 注意权限与文件编码（全部使用 UTF-8，无 BOM）；  
   - 系统相关逻辑尽量封装，通过配置或常量集中管理，减少平台差异带来的修改面。

7. **代码注释侧重“为什么”，不赘述“是什么”**  
   - 对于能从代码本身直接看出的行为，不写多余注释；  
   - 对于魔法数字、特殊硬件限制、非直观算法步骤，优先解释设计原因与约束条件；  
   - 较长的背景或决策过程，可放到对应的 `*_journey.md`，在代码中只留简要链接或关键词。

---

## 3. 测试与验证原则（Testing & Validation Principles）

1. **REPL 优先验证硬件相关改动**  
   - 新增或修改底盘、云台、发射器相关控制指令时，先在 `src/repl.py` 中通过交互式命令验证；  
   - 在文档（如 `repl.md` 或 Journey 文档）中记录关键 REPL 命令与预期行为，形成可重复的验证用例。

2. **先小范围验证，再集成测试**  
   - 对于新特性（如自瞄策略、目标选择算法），先在单模块或小范围脚本中验证正确性与性能；  
   - 通过初步验证后，再集成进主流程（如 `main.py`、技能系统），减少故障排查复杂度。

3. **在树莓派上进行最终性能与稳定性评估**  
   - 性能与实时性相关逻辑（视觉推理、自瞄控制、串口通信）必须在目标硬件上实际测量；  
   - 在 `status.md` 中同步：已测环境、FPS、延迟范围以及主要瓶颈所在；  
   - 如遇到性能问题，优先通过 Journey 文档记录“问题—分析—优化—结果”闭环。

4. **测试结果要可追溯**  
   - 尽管当前自动化测试相对薄弱，但仍应：  
     - 在文档中注明哪些脚本/命令已经在何种环境下验证；  
     - 在 Journey 文档记录重要实验的参数与结果；  
   - 未来如引入单元测试 / 集成测试，应将测试结构与覆盖范围记录在相应文档中。

5. **避免一次性大改，倾向渐进式重构**  
   - 对于高风险模块（如自瞄 pipeline、串口通信），优先采用“小步重构 + 频繁验证”的方式；  
   - 每次改动保持可测试、可回滚，必要时在 Journey 文档中标记关键里程碑。

---

## 4. 项目管理与协作原则（Project Management Principles）

1. **以文档为中枢的协作模式**  
   - `.github/copilot-instructions.md` 用于约束 LLM 行为与提供项目元信息；  
   - `docs/index.md` 提供文档导航与命名规则；  
   - `docs/status.md` 提供当前状态快照；  
   - intro/journey/ops 文档构成“知识库”，供人类与 LLM 在开发时查询和扩展。

2. **尽量让决策显性化并可复盘**  
   - 对于重要的技术或架构决策，不仅要在代码中体现结果，还要在 `*_journey.md` 中说明：  
     - 备选方案；  
     - 决策理由（性能、可维护性、硬件限制等）；  
     - 决策带来的已知利弊。  
   - 这样可以在未来重构或新成员加入时减少“重新走弯路”的概率。

3. **保持文档与代码的一致性是共同责任**  
   - 当发现文档与代码不一致时，应优先更新最权威的事实来源：  
     - 架构事实 → 对应 `*_intro.md`；  
     - 历史和问题 → 对应 `*_journey.md`；  
     - 当前状态 → `status.md`；  
   - 鼓励在 PR / 变更评审中检查相关文档是否需要同步更新。

4. **避免过度设计文档体系，优先服务当前需求**  
   - 文档类型与命名规则尽量简洁，不引入过多层级与文件种类；  
   - 当发现某类信息反复出现在多处时，再考虑抽象成新的文档类型或章节；  
   - 目标是让文档体系既对 LLM 友好，又不会让人类维护成本失控。

5. **以真实使用场景驱动文档与代码改进**  
   - 优先满足以下场景的需求：  
     - 比赛现场调试与快速排错；  
     - 新功能接入与参数调优；  
     - 赛后复盘与性能分析；  
   - 在这些场景中暴露出来的问题，应优先反馈到：  
     - 代码结构与接口设计；  
     - 文档的完整性与可读性；  
     - Copilot 规则与 LLM 提示模式。

---

## 5. 如何使用这些原则

- 在**写代码**时：
  - 对照第 2 节，检查命名、参数校验、日志与层次划分是否符合当前约定；
  - 在涉及硬件控制或性能敏感逻辑时，额外关注范围校验与目标环境兼容性。

- 在**写文档**时：
  - 对照第 1 节，确认当前写的是哪一类文档（intro、journey、ops、状态）；
  - 避免在一个文档中混杂过多角色，必要时拆分并互相链接。

- 在**做测试与验证**时：
  - 对照第 3 节，优先考虑 REPL 验证、小步集成和目标硬件上的真实表现；
  - 重要结论应沉淀到 `status.md` 或相关 Journey 文档。

- 在**做项目管理与协作**时：
  - 对照第 4 节，确保每次较大改动都有相应的文档更新或记录；
  - 将 `copilot-instructions.md` + `index.md` + `status.md` 视为 LLM 与人类沟通的“操作手册”。
