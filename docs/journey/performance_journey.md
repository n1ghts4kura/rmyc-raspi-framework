---
title: 性能调优全程记录（Raspberry Pi + 视觉自瞄链路）
version: 2025-10-18
status: draft
maintainers:
	- n1ghts4kura
	- GitHub Copilot
category: journey
last_updated: 2025-11-23

history_scope: "从 demo_vision 初版 ~1FPS 到稳定 4+ FPS 的性能调优过程，涵盖推理后端、电源与 CPU governor、主循环与线程模型等关键因素。"
history_period: "2025-10-02 ~ 2025-10-18"
history_tags:
	- performance
	- recognizer
	- aimassistant
	- raspberry-pi
	- power-supply
	- threading

llm_summary: >
	本文记录了在树莓派上运行视觉识别与自瞄链路时，从最初约 1FPS 的 demo_vision 初版，
	逐步提升到稳定 4+ FPS 的调优全过程。内容包括：time.sleep 调度精度问题、电源不足导致 CPU
	自动降频、NCNN 后端不稳定与 ONNX Runtime 的取舍、主循环与推理线程的竞态与资源争用、
	以及最终在「体验可接受 / 能耗可控 / 调试复杂度可接受」三者之间做出的折中方案。

llm_entry_points:
	- "如果你在树莓派上遇到 FPS 不稳定或突然跌到 1FPS，请先阅读本篇。"
	- "如果你在比较不同推理后端（NCNN / ONNX Runtime / TorchScript），本篇给出实际踩坑记录。"
	- "如果你怀疑电源或 CPU governor 影响了性能，本篇有完整的诊断路径与建议。"
---

## 性能调优全程记录（Performance Journey）

> 目标：把「demo_vision + 自瞄链路在树莓派上的性能问题」从一堆零散实验日志，
> 抽象成一条可复用的调优路径，帮助未来在类似环境下快速定位瓶颈、少踩坑。

---

## 1. 初始状态：约 1FPS 的 demo_vision

本节描述尚未引入系统性调优之前，demo_vision 在树莓派上的**原始表现**与环境假设。

### 1.1 运行环境与约束

- 硬件：树莓派型号、内存规格、供电方式（如 USB 口供电 / 单独 5V 适配器等）；
- 软件：Python 版本、OpenCV 版本、ONNX Runtime / NCNN / Torch 版本；
- 相机与分辨率：`CAMERA_WIDTH` / `CAMERA_HEIGHT` 的配置，是否启用显示窗口；
- 目标：在保持自瞄可用前提下，尽可能提高 FPS 并降低感知延迟。

> TODO：在实际运行和测量后，将具体硬件型号与关键软件版本补充到本小节。

### 1.2 初版 demo_vision 的表现

- 典型症状：
  - 推理帧率约为 1FPS 左右，画面明显卡顿；
  - 自瞄响应有明显迟滞，移动目标时跟随不连续；
  - CPU 占用高且不稳定，偶尔出现温度较高或系统卡死现象。
- 初步怀疑方向：
  - 模型过大 / 后端效率低；
  - 主循环中存在不必要的阻塞（如 `time.sleep` 使用不当）；
  - 树莓派电源与 CPU governor 影响频率。

> 这一阶段几乎是「一切堆在一起跑跑看」，还没形成系统化的性能观。

---

## 2. 阶段一：清理主循环与 sleep 逻辑

### 2.1 问题暴露

- 在初步代码审查与日志观察中，发现：
  - 主循环中存在固定 `time.sleep` 调用，且与摄像头读帧 / 推理逻辑耦合；
  - 推理与渲染/显示未明确分离，导致一帧慢拖累整条链路；
  - 日志时间戳显示帧间间隔不稳定，说明 sleep 与实际耗时叠加后抖动明显。

### 2.2 探索与尝试

- 尝试 A：简单缩短或移除部分 `time.sleep`：
  - 优点：实现简单，FPS 在某些场景下确实略有提升；
  - 缺点：CPU 占用大幅拉高，系统温度上升，且未解决结构性抖动问题。
- 尝试 B：将读取相机帧和推理解耦，采用更清晰的流程控制：
  - 思路：
    - 读帧 → 推理 → 渲染/输出 分步统计耗时；
    - 只在必要时 sleep，避免多个环节叠加休眠；
  - 现象：稍微改善，但单线程结构仍决定了最慢环节拖累整体。

### 2.3 阶段小结

- 结论：
  - 盲目删减 `time.sleep` 只会在 CPU 与能耗上「透支」，不会根治 FPS 不稳；
  - 性能瓶颈更多来自「推理耗时 + 单线程主循环结构」，需要更高层次的调整。
- 经验：
	- 优先用日志或简单的耗时统计，搞清「每一帧时间花在哪」；
	- 不要指望通过微调 sleep 把 1FPS 变成 4FPS。

---

## 3. 阶段二：电源、CPU governor 与降频问题

### 3.1 异常现象与线索

- 即使在同一代码版本下，长时间运行后 FPS 会突然下降到 1FPS 附近；
- 树莓派温度与 `vcgencmd get_throttled` 输出显示存在降频 / 降压情况；
- 更换电源适配器或供电方式后，性能表现有明显差异。

### 3.2 诊断过程

- 检查供电：
	- 使用不同电源适配器（额定电流、线材质量）对比运行表现；
	- 观察系统日志和 `dmesg`，是否存在电压不足相关提示。
- 检查 CPU governor 与频率：
	- 使用 `cpufreq-info` / `cpufreq-set` / `vcgencmd` 等工具查看当前 governor（如 `ondemand` / `powersave` / `performance`）；
	- 记录在不同 governor 设置下的 FPS 和温度变化。

### 3.3 关键决策

- 决策 1：为性能调试场景单独配置 `performance` governor：
	- 理由：
		- 在调优阶段，希望 CPU 频率尽可能稳定，避免节能策略引入额外噪声；
	- 权衡：
		- 温度与功耗会上升，需要配合散热与合理的运行时长控制。
- 决策 2：为项目提供一套「CPU 性能模式脚本」：
	- 对应仓库中的 `tools/set_cpu_performance.sh` / `install_cpu_performance_service.sh` 等脚本；
	- 通过脚本化方式快速切换到「性能模式」，并在 `docs/reference` 或 `status.md` 中标注使用建议。

### 3.4 阶段小结

- 结论：
	- 电源与 CPU governor 对性能影响巨大，可能超过单纯的代码微调；
	- 在 FPS 掉到 1FPS 的场景下，首先要验证是否存在降频，而不是一味怀疑模型或算法。
- 经验：
	- 性能调优必须把「硬件供电、散热、CPU 策略」纳入假设前提；
	- 任何性能指标都需要记录对应的硬件与 governor 设置，否则结论不可复用。

---

## 4. 阶段三：推理后端的选择与踩坑（NCNN / ONNX Runtime / TorchScript）

### 4.1 备选方案与初始假设

- NCNN：
	- 优点（理论上）：轻量、针对移动设备优化，有可能在树莓派上表现更好；
	- 风险：生态文档相对较少，与现有 Python 推理链路整合成本较高。
- ONNX Runtime：
	- 优点：生态成熟，工具链完善，模型转换路径相对清晰；
	- 风险：在树莓派上的性能是否足够，需实际测试验证。
- TorchScript：
	- 优点：与训练端 PyTorch 对接最自然；
	- 风险：树莓派部署体积大、依赖复杂、冷启动与内存占用偏高。

### 4.2 实际测试与问题

- NCNN 路线：
	- 遇到的问题：
		- 在某些配置下推理过程不稳定，偶尔出现崩溃或结果异常；
		- Debug 难度较高，缺乏清晰的日志与诊断手段；
	- 临时结论：
		- 虽然在某些场景下有潜在性能优势，但在当前项目时间与维护成本下不划算。
- ONNX Runtime 路线：
	- 现象：
		- 在合理的模型压缩与输入尺寸设置下，可以稳定跑到 4+ FPS；
		- API 相对稳定，出错信息也比较可读；
	- 风险点：
		- 初次加载模型的冷启动时间，及少数算子在 ARM 平台上的实现差异，需要提前测试。
- TorchScript 路线（可选探讨）：
	- 目前更多是作为“备用选项”讨论，尚未在树莓派上全面部署。

### 4.3 最终选择与理由

- 阶段性结论：优先选用 ONNX Runtime 作为树莓派运行时后端：
	- 理由：
		- 稳定性与调试体验更好；
		- 在本项目当前分辨率和模型规模下，性能可以满足 4+ FPS 的目标；
		- 与训练端（YOLOv8 导出 ONNX）之间转换链路成熟。
- 未选 NCNN 的原因：
	- 运行稳定性和调试成本不理想，且项目人力有限；
	- 若未来有足够时间，可在新分支中单独探索 NCNN 优化路径。

---

## 5. 阶段四：线程模型与主循环重构

### 5.1 问题：推理与主循环互相拖累

- 现象：
	- 当推理耗时波动时，主循环的控制频率也随之抖动；
	- 自瞄控制与视觉推理为同一线程服务时，任何一方卡顿都会放大整体延迟；
	- 日志显示某些时刻帧间隔远大于单次推理耗时，说明存在额外阻塞。

### 5.2 多线程/异步方案的探索

- 方案 A：推理与主循环分线程：
	- 思路：
		- 由一个线程专门负责读帧 + 推理，将结果写入共享缓冲区；
		- 主线程只负责读取最新结果并驱动自瞄控制；
	- 注意点：
		- 需要处理线程间数据同步与生命周期管理，避免读到半成品结果。
- 方案 B：基于队列的生产者/消费者模型：
	- 思路：
		- 摄像头采集与推理作为生产者，主循环作为消费者；
		- 队列深度有限，防止累计延迟过大；
	- 风险：
		- 若未做好丢帧策略，可能造成延迟堆积。

### 5.3 最终落地的线程模型（阶段性）

- 采用「推理线程 + 控制主循环」的结构：
	- 推理线程负责持续从相机获取帧并进行识别，将最新目标信息写入共享状态；
	- 控制主循环以固定频率读取共享状态，更新自瞄控制与底盘动作；
	- 通过合理的锁/原子操作或简单策略，保证读写互斥开销不过高。

### 5.4 阶段小结

- 结论：
	- 将推理与控制解耦是从「能跑」迈向「跑得稳」的关键一步；
	- 即使单帧推理耗时不变，线程模型调整也能显著改善体验（减少长尾卡顿）。
- 经验：
	- 在涉及视觉 + 控制的链路中，应尽量保证控制主循环的节奏稳定，把推理视作「异步信号源」。

---

## 6. 最终指标与对比

### 6.1 指标对比表（示例占位）

| 阶段                  | 平均 FPS | 延迟感受         | CPU 占用 | 温度/降频情况       | 备注                         |
|-----------------------|---------:|------------------|---------:|----------------------|------------------------------|
| 初版 demo_vision      |    ~1.0  | 明显卡顿         |   高且抖动 | 偶发降频/温度告警   | 单线程，sleep 使用混乱      |
| 调整 sleep 后        |   1.2–1.5| 略有改善         |    很高  | 温度偏高            | 盲目削减 sleep，收益有限    |
| 性能 governor + 电源  |   2.0–3.0| 有卡顿但可接受   |   稳定偏高 | 降频显著减少        | 电源与 governor 配置优化    |
| ONNX Runtime + 多线程 |   4.0+   | 基本流畅         |   可接受 | 温度与功耗在可控范围 | 当前推荐方案                |

> TODO：根据实际测试结果，将 FPS、CPU、温度等指标补充为真实数据。

### 6.2 与目标的匹配程度

- 目标：
	- 在树莓派上实现「可用于比赛场景的」自瞄体验：FPS ≥ 4，延迟可接受，系统长时间运行稳定；
- 现状：
	- 通过一系列调整后，已在实验环境中达到并维持 4+ FPS；
	- 仍需在真实比赛环境下进行长时间验证与压力测试。

---

## 7. 经验教训与未来方向

### 7.1 经验教训

- 性能问题往往是多因素叠加的结果：
	- 硬件供电与散热 → CPU governor → 推理后端 → 主循环结构 → 日志与调试开销；
- 不要指望通过单一「神奇参数」解决所有问题，系统性地分阶段诊断更靠谱；
- 性能调优过程本身应被记录下来（正如本篇），为未来的重构与新硬件迁移提供样本。

### 7.2 对未来调优的建议

- 在引入新模型或更高分辨率前：
  - 先在已有 pipeline 上做 baseline 测试，确认当前瓶颈位置；
- 在考虑新的推理后端（如 NCNN、TensorRT 等）时：
  - 单独开分支和 journey，避免与当前稳定方案互相干扰；
- 在准备比赛或长时间运行场景时：
  - 把性能测试脚本（包括 governor 切换和简单压力测试）纳入日常流程，并在 `status.md` 中标记结果。

### 7.3 与其他文档的关系

- 与 `v1_0_history.md`：
	- 本文更多聚焦性能这一主题，而 `v1_0_history.md` 是版本整体发展史，两者互为补充；
- 与 `aimassistant_journey.md`：
	- 自瞄的行为与性能强相关，该文档在需要细究 FPS 与延迟来源时，是推荐的配套阅读；
- 与 `docs/reference/sdk_protocol_api_document.md`：
	- 协议层面对性能的直接影响有限，但串口频率与消息量设计仍需参考协议文档进行权衡。

---

> 本文是对旧 `PERFORMANCE_OPTIMIZATION_HISTORY.md` 等长日志的结构化复盘，
> 后续如在新硬件或新模型上进行大规模性能调优，建议在本篇基础上追加新阶段，
> 或单独撰写新的性能 journey 文档，并在 YAML 头中明确区分历史范围。

