---
title: v1.0 版本开发历程总览
version: v1.0
status: archived
maintainers:
	- n1ghts4kura
	- GitHub Copilot
category: journey
last_updated: 2025-10-18

history_scope: "从零到 v1.0：机器人控制基础框架的完整搭建过程"
history_period: "2025-09-25 ~ 2025-10-04"  # 时间段为推测，可按实测调整
history_tags:
	- versioning
	- architecture
	- bot
	- skill
	- recognizer
	- repl

llm_summary: >
	本文压缩记录了 v1.0 版本从空仓库到完整基础框架成型的全过程：
	包括项目初始化、串口通信与硬件控制 API、技能系统、视觉识别、REPL 调试工具、
	日志系统以及主循环的关键设计与决策。它回答的是「为什么 v1.0 会长成现在这个样子」、
	「哪些结构是后续自瞄与性能优化的前提」，适合作为理解整个项目技术基底的历史入口。

llm_entry_points:
	- "当你需要回顾 v1.0 阶段到底做了什么、没做什么时，先读本篇。"
	- "在设计 v2.x 大改或重构时，如果想确认哪些基础假设来自 v1.0，可以先读本篇。"
	- "当你需要写项目整体架构文档时，可将本篇作为按时间维度的参考补充。"
---

# v1.0 版本开发历程（压缩版）

> 本文是旧版 `development_history_v1.md` 的结构化压缩视图，
> 只保留与当前架构和后续演进密切相关的关键内容。
> 如需查看更细节的原始记录，可参考：`old_docs/documents/history/development_history_v1.md`。

---

## 1. 阶段与目标概览

### 1.1 版本定位

- 版本号：v1.0
- 阶段名称：基础框架建设
- 目标时间：约 2025 年 9 月底 ~ 10 月初（具体以 git 为准）
- 版本定位：
	- 建立**完整的机器人控制基础框架**；
	- 不包含自瞄闭环（那是 v1.1 的目标）。

### 1.2 v1.0 的核心诉求

- 串口通信：一套可靠、非阻塞、可复用的 UART 通信层；
- 硬件控制：对底盘、云台、发射器和机器人状态的 API 封装；
- 技能系统：基于键盘按键触发的技能框架，支持扩展；
- 视觉识别：YOLO 模型推理入口和摄像头采集逻辑；
- 调试工具：REPL 串口调试工具，便于联调和运维；
- 日志系统：统一的彩色日志与 DEBUG 开关。

> 可以理解为：v1.0 的目标是“造出一台可以被 Python 驾驶的 EP/S1”，
> 而不是“造出一套会自瞄的战斗系统”。

---

## 2. 按阶段划分的时间线

本节用较粗粒度的阶段来串联 v1.0 期间的主要工作，
具体细节在后续章节按子系统展开。

1. 项目初始化与技术栈确认
2. 串口通信与硬件抽象层搭建（`src/bot/`）
3. 日志系统接入（`logger.py`）
4. 技能系统框架搭建（`src/skill/`）
5. 视觉识别入口实现（`src/recognizer.py`）
6. REPL 调试工具实现（`src/repl.py`）
7. 主循环与整体 glue code（`src/main.py`）
8. v1.0 文档与总结（`general_intro_for_ai.md` + 本历史）

在实践中，这些阶段存在一定交叉和平行推进，
但总体顺序大致沿着「先通信和抽象、再行为和视觉、最后 glue 和文档」的方向展开。

---

## 3. 通信与硬件抽象层（`src/bot/`）

### 3.1 设计目标

- 将 RoboMaster SDK 的串口协议封装在统一的通信层之下；
- 对上提供**语义化的硬件控制 API**（如 `set_chassis_speed_3d`、`move_gimbal` 等）；
- 把“收发细节”和“命令组织”隐藏到 `src/bot/` 内部，
	让业务层和技能层不需要关心串口状态机和数据帧解析。

### 3.2 核心实现要点

1. 串口通信（`conn.py`）：
	 - 后台接收线程持续从串口读入数据；
	 - 使用**双队列设计**：
		 - 行级队列 `_rx_queue`：按换行符分割的原始行；
		 - 命令级队列 `_cmd_queue`：按分号分割的 SDK 命令；
	 - 对外提供非阻塞接口：`get_serial_line_nowait()`、`get_serial_command_nowait()`；
	 - 使用 `serial_conn_lock` 保证多线程访问串口时的安全。

2. 硬件控制 API：
	- `sdk.py`：进入/退出 SDK 模式；
	- `chassis.py`：三维速度控制、相对位移、轮速控制等；
	- `gimbal.py`：云台相对/绝对角度控制、回中、速度设置（v1.0 仅支持 ±55° 相对角度）；
	- `blaster.py`：发射控制（发弹数有严格范围校验）；
	- `game_msg.py`：将 `game msg push` 消息解析为按键事件；
	- `robot.py`：机器人整体状态查询。

3. 参数校验与异常处理：
	- 所有对硬件有副作用的 API，都在入口处做**范围检查**，不满足条件直接抛出异常；
	- 这在 v1.0 就已经贯彻，为后续任何高层逻辑提供了安全边界。

### 3.3 关键决策与后果

- 采用非阻塞串口读取 + 后台线程的模式：
	- 好处：主循环永不被阻塞，适合将来叠加技能、自瞄等复杂逻辑；
	- 代价：v1.0 并没有引入“指令执行是否成功”的反馈通路，这成为 v1.1 讨论
		`uart_feedback` 机制时需要权衡的技术债之一。

### 3.4 典型坑点与排查片段

- 早期曾遇到“偶尔整句指令被拆成两半”的问题：
  - 现象：日志中看到 `chassis speed x 1` 和 `y 0 z 0;` 分成两行，机器人无响应；
  - 原因：串口读线程按行缓冲，但一行中可能包含多个以分号结尾的命令，
    而上层又直接拿“行”当成完整指令使用；
  - 解决：引入命令级队列 `_cmd_queue`，在行级缓冲基础上再按分号切割，
    并保证重组时保留分号作为结束标记。

- 另一个隐蔽问题是“假死但没有异常”：
  - 现象：主循环长时间拿不到任何命令，日志没有报错；
  - 原因：串口读取遇到极端情况下的阻塞，未正确设置超时；
  - 解决：为串口设置合理超时时间，并在后台线程中通过 0.1s 级别的空闲判断
    来结束当前缓冲帧，避免读操作无限期挂起。

这些细节在旧文档中以多段零散文字出现，这里只保留结论性的经验，
完整过程可以在需要时回看 `development_history_v1.md`。

---

## 4. 技能系统（`src/skill/`）

### 4.1 设计目标

- 提供一个**键盘按键 → 机器人复杂行为**的映射层；
- 每个技能是一个相对独立的“脚本单元”，通过统一接口接入；
- 技能的执行不阻塞主循环，支持中途取消和错误标记。

### 4.2 核心结构

- `BaseSkill`：
	- 属性：`binding_key`、`name`、`enabled`、`errored`、`thread_handle`；
	- 行为：同步执行、异步执行（新线程）、异步取消（带超时）。

- `SkillManager`：
	- 管理所有技能实例，保证**键位唯一性**；
	- 提供 `invoke_skill_by_key` / `cancel_skill_by_key` / `get_skill_enabled_state`；
	- 在主循环中由 `game_msg_process` 解析出的按键触发。

### 4.3 按键驱动的互斥模式

- 同一个键位：
	- 第一次按下 → 启动对应技能；
	- 再次按下 → 请求取消对应技能（等待线程退出，带超时）。
- 这一模式为后续“自瞄技能”“快速移动技能”等提供了非常自然的操作语义：
	- 再按一次就是“停下/取消”。

### 4.4 v1.0 对后续的影响

- v1.0 的技能系统已足够承载 v1.1 的自瞄；
- 后续如果要引入更复杂的“技能编排/优先级/互斥组”，可以在这一基础上演进，
	无需推倒重来。

### 4.5 典型设计取舍与小问题

- 键位策略的取舍：
  - 早期曾考虑“按下 = 开启本技能，松开 = 停止技能”的连续按键模型，
    但和 RoboMaster 的键值上报模型不完全契合；
  - 最终采用“同一个键位按第二次表示取消/停止”的方案，
    既满足人类操作直觉，也简化了 `game_msg` 与技能层之间的协议。

- 线程模型上的一个小坑：
  - 初版技能线程没有对异常做统一捕获，导致某技能抛出未处理异常时线程直接死亡，
    但 `enabled` 状态没有及时复位；
  - 后续为所有技能执行路径增加 try/except 包装，并在异常时：
    - 记录错误日志；
    - 将 `errored` 标记置位，`enabled` 复位；
    - 这样不会因为一次错误导致后续无法再触发该技能。

---

## 5. 视觉识别（`src/recognizer.py`）

### 5.1 设计目标

- 把摄像头帧采集和 YOLO 推理包装成一个相对独立的“识别服务”；
- 使用双线程结构分离 I/O 与推理；
- 对外提供简单的 `get_latest_result()`、`get_fps_info()` 等接口。

### 5.2 v1.0 的实现轮廓

- 采集线程：
	- 不断从摄像头读取最新帧，存入共享变量；
	- 负责处理设备打开失败、分辨率设置等问题；
- 推理线程：
	- 周期性取出最新帧，执行 YOLO 推理；
	- 维护最近一次推理结果和相关统计信息。

初始性能：

- 采集 FPS：约 30 FPS（摄像头物理上限）；
- 推理 FPS：约 0.7 FPS（PyTorch 后端，未做针对树莓派的优化）；
- 这在 v1.0 只作为“证明链路打通”的基线，性能问题全部留给 v1.1 的性能 journey 处理。

### 5.3 早期踩过的几个坑

- 摄像头设备选择：
	- 一开始默认使用 `/dev/video0`，在本地 USB 摄像头和树莓派 CSI 摄像头之间切换时
		频繁踩坑；
	- 后续在代码中引入了更明确的设备选择逻辑，并在日志中打印当前使用的设备路径，
		方便在 REPL 和远程终端中确认实际接入的摄像头。

- 帧率统计的陷阱：
	- 早期 FPS 统计逻辑直接用“推理次数 / 总时间”，没有排除初始化和空闲期，
		导致日志中的 FPS 数值偏高且不稳定；
	- v1.0 后期和 v1.1 期间，对 FPS 统计进行了重写：
		- 分别统计采集和推理两条路径；
		- 引入滑动窗口或指数平滑，避免因为短期抖动得出误判结论。

### 5.3 与自瞄的关系

- v1.0 的视觉识别**并不包含**任何自瞄逻辑：
	- 没有目标排序策略；
	- 没有角度计算和云台控制调用；
	- 没有任何与发射器联动的逻辑。
- 它更像是后续自瞄系统的“感知源头”，为 v1.1 的 `aimassistant` 模块提供输入。

---

## 6. REPL 调试工具（`src/repl.py`）

### 6.1 设计目标

- 提供一个**脱离主程序、专注于串口交互**的调试入口；
- 用彩色输出区分发送/接收信息；
- 提供少量内置命令简化常见操作。

### 6.2 关键特性

- 基于 `prompt_toolkit` 的交互式命令行：
	- 用户输入的命令以特定颜色显示；
	- 后台线程实时打印机器人返回的串口数据；
	- 支持 Ctrl+C 中断当前输入而不退出进程，Ctrl+D 退出 REPL。

- 内置命令示例：
	- `help`：查看帮助；
	- `reconnect`：重新打开串口；
	- `exit`：优雅退出；
	- `clear`：清屏。

### 6.3 作用与遗产

- v1.0 阶段，REPL 是**几乎所有硬件联调的唯一入口**；
- 后续任何新硬件控制 API、自瞄动作、底盘运动方案，在进主程序前都可以先在 REPL 里验证；
- 这一“REPL 优先验证”的理念，已被固化进 `.github/copilot-instructions.md` 和文档原则中。

### 6.4 使用过程中的经验片段

- 通过 REPL 发现的一类典型问题是“命令语法与 SDK 文档不完全一致”：
	- 例如某些命令需要以分号结尾，否则机器人直接忽略；
	- 通过在 REPL 中逐条尝试、对比官方示例和实际返回内容，
		最终梳理出一套可靠的命令模板，并在 `sdk_protocol_api_document.md` 中沉淀。

- 另一个收获是确认了“开发机上跑 main.py 没有意义”这一事实：
	- 在 REPL 中多次尝试后，进一步明确了：
		- 真正的验证应当发生在树莓派 + 机器人实机环境；
		- 开发机更多用于静态检查、结构推演和文档生成，
		- 这也在后续的 `status.md` 与 `principles.md` 中演化为“一律不在开发机上宣称验证通过”的约定。

---

## 7. 主循环与 glue 层（`src/main.py`）

### 7.1 设计目标

- 在不引入复杂框架的前提下，把通信层、技能层、（可选的）视觉层 glue 在一起；
- 保持主循环逻辑直观，便于后续扩展和重构。

### 7.2 主循环核心逻辑（概念级）

- 持续从 `conn.get_serial_command_nowait()` 读取命令；
- 如果是 `game msg push`，则调用 `game_msg_process` 解析出键位；
- 对于每个键位：
	- 若技能正在运行 → 调用 `cancel_skill_by_key`；
	- 否则 → 调用 `invoke_skill_by_key`；
- 在退出前调用 `exit_sdk_mode()` 释放机器人控制权，并捕获 `KeyboardInterrupt` 做清理。

### 7.3 对后续版本的影响

- 这个简单的主循环为 v1.1 的自瞄技能接入提供了明确挂钩点；
- 未来如果要重构为事件驱动框架或引入协程，该主循环可以作为 v1.x 时代的“原型参考”。

---

## 8. v1.0 的成果与技术债

### 8.1 已完成的基础

- 通信层：后台线程 + 双队列的串口通信；
- 抽象层：对底盘、云台、发射器和机器人状态的封装；
- 行为层：以键盘按键为入口的技能系统；
- 感知层：基于 YOLO 的视觉识别入口；
- 调试层：REPL 工具和统一日志系统；
- 文档层：`general_intro_for_ai.md` 等 v1.0 说明性文档。

### 8.2 明确留给后续版本的事项

- 性能：
	- 初始 FPS 非常有限，树莓派 CPU 资源利用不佳 → v1.1 的性能 journey 重点解决；

- 功能：
	- 自瞄链路（目标选择、角度解算、云台/发射控制）完全留给 v1.1；
	- 全局配置系统和参数集中管理也未在 v1.0 内完成；

- 可靠性：
	- 串口指令执行是否有反馈、是否需要 ack 机制，在 v1.0 只作为“假定成功”处理，
		这在后续 `uart_feedback_journey` 中会有更深入讨论。

---

## 9. 如何使用本历史文档

对于人类开发者：

- 如果你刚接手项目，需要理解“为什么会有当前这套分层”，可以先读：
	- `docs/index.md`（文档导航与类型说明）；
	- `docs/plans.md`（版本视角的过去/现在/未来）；
	- 然后再回到本 `v1_0_history.md` 作为“时间维度的补充说明”。

- 如果你计划重构某一层（比如通信层或技能系统），可以：
	- 在本篇中找到对应章节（`src/bot/`、`src/skill/`、`src/recognizer.py` 等）；
	- 再结合源码和未来的 `*_intro.md` 文档一起阅读。

对于 LLM：

- 在需要生成**整体架构文档**或**版本演进说明**时，
	应优先结合：`docs/status.md` + `docs/plans.md` + 本文；
- 如需更细节的历史素材（例如某个具体函数的演化），
	再按需读取 `old_docs/documents/history/development_history_v1.md`，
	避免无谓地把整篇长文全部塞入上下文。 

