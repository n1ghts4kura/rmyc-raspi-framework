# 滑环云台 360° 旋转功能实现记录

**更新说明**: 2025年10月3日 - 将函数重命名为 `rotate_gimbal` / `rotate_gimbal_absolute`，旧版函数改为#### 3. 旧版函数状态

- `_move_gimbal()`: 私有函数，仅 ±55°，内部调用
- `_move_gimbal_absolute()`: 私有函数，内部调用
- **不再导出到 __all__**: 用户无法直接调用，避免 API 混乱move_gimbal` / `_move_gimbal_absolute`）

---

## 背景

### 硬件改装
- **原始状态**: RoboMaster EP 云台有机械限位卡扣，限制旋转角度
- **改装方案**: 添加滑环（slip ring）组件
- **改装效果**: 理论上可以实现无限角度旋转

### 技术挑战
- **UART 协议限制**: 下位机仅接受 ±55° 的相对角度输入
- **绝对角度限制**: pitch ∈ [-25, 30]°, yaw ∈ [-250, 250]°
- **需求**: 实现任意大角度旋转（如 180°掉头、360°扫描）

---

## 设计方案

### 核心思路：角度分解算法

将大角度分解为多个小步进，每步 ≤50°（留 5° 安全余量）：

```
输入: 180° @ 90°/s
分解:
  步进1: +50° → 等待 50/90 + 0.1 = 0.66s
  步进2: +50° → 等待 0.66s
  步进3: +50° → 等待 0.66s
  步进4: +30° → 等待 30/90 + 0.1 = 0.43s
总耗时: 2.41s
```

### 时间计算公式

```python
等待时间 = abs(step_angle) / speed + 0.1s
         ↑ 匀速运动时间      ↑ 稳定缓冲
```

- **物理依据**: 匀速直线运动公式 `t = s/v`
- **缓冲时间**: 0.1s（经验值，待硬件实测调优）
  - 考虑因素：机械启动延迟、加速/减速过程、稳定时间

---

## 实现细节

### 函数设计

#### 1. `rotate_gimbal()` - 相对角度 360° 旋转（主操作函数）

```python
def rotate_gimbal(
    pitch: float | None = None,
    yaw: float | None = None,
    vpitch: float | None = None,
    vyaw: float | None = None
) -> None:
    """
    【主操作函数】支持滑环改装后的 360° 无限旋转（相对角度模式）。
    """
```

**特性**:
- ✅ 支持任意大角度输入（无上限）
- ✅ 自动分解为 ≤50° 的步进
- ✅ 基于物理公式的时间延迟
- ✅ 阻塞执行（确保运动完成）
- ✅ pitch 和 yaw 独立处理

**应用场景**:
- 自瞄系统的目标跟踪（推荐）
- 快速掉头（180°）
- 全场扫描（360°）
- 连续追踪（540°+）

#### 2. `rotate_gimbal_absolute()` - 绝对角度 360° 旋转（主操作函数）

```python
def rotate_gimbal_absolute(
    pitch: float | None = None,
    yaw: float | None = None,
    vpitch: float | None = None,
    vyaw: float | None = None
) -> None:
    """
    【主操作函数】支持滑环改装后的 360° 无限旋转（绝对角度模式）。
    """
```

**特性**:
- ✅ 目标角度在下位机范围内 → 直接使用 `move_gimbal_absolute()`
- ✅ 超出范围 → 转换为相对角度，调用 `move_gimbal_360()`
- ⚠️ 超出范围时可能存在累积误差

**应用场景**:
- 需要精确到达指定绝对位置
- 预设姿态切换
- 初始化/校准位置

#### 3. 旧版函数状态

- `move_gimbal()`: 标记为"旧版，有角度限制"，仅 ±55°
- `move_gimbal_absolute()`: 标记为"旧版，有角度限制"
- **保留原因**: 向后兼容、小角度场景性能更优

---

## 自瞄系统集成

### 修改内容

**文件**: `src/aimassistant/pipeline.py`

**修改前**:
```python
from bot.gimbal import move_gimbal, set_gimbal_recenter
# ...
move_gimbal(pitch=pitch_offset, yaw=yaw_offset, ...)
```

**修改后**:
```python
from bot.gimbal import rotate_gimbal, set_gimbal_recenter
# ...
rotate_gimbal(pitch=pitch_offset, yaw=yaw_offset, ...))
```

### 优势分析

1. **突破限制**: 目标跳跃 >55° 时不再受限
2. **无需判断**: 小角度也能正常工作（自动优化）
3. **未来扩展**: 支持 360° 连续追踪

### 注意事项

⚠️ **阻塞执行**: `rotate_gimbal()` 会阻塞线程
- 自瞄运行在独立线程 → 不影响主循环 ✅
- 单次控制耗时 = 角度分解步数 × (步进时间 + 0.1s)
- 例: 180° @ 90°/s ≈ 2.4s

---

## 测试验证

### 模拟测试

**脚本**: `test_rotate_gimbal.py`

**测试用例**:
| 角度  | 速度   | 步数 | 耗时   | 场景描述       |
|-------|--------|------|--------|----------------|
| 45°   | 90°/s  | 1    | 0.60s  | 小角度直接发送 |
| 180°  | 90°/s  | 4    | 2.40s  | 快速掉头       |
| 360°  | 90°/s  | 8    | 4.80s  | 全场扫描       |
| -270° | 120°/s | 6    | 2.85s  | 反向大角度     |
| 540°  | 180°/s | 11   | 4.10s  | 高速连续追踪   |

**验证结果**: ✅ 算法逻辑正确，时间计算基于物理公式

### 待硬件测试

#### 测试步骤
1. 在 Raspberry Pi 上运行实际控制代码
2. 使用 REPL 工具手动发送指令
   ```python
   from bot.gimbal import rotate_gimbal
   rotate_gimbal(yaw=180, vyaw=90)
   ```
3. 观察实际旋转时间、稳定性
4. 调优 `0.1s` 缓冲时间（必要时增大）

#### 验证项目
- [ ] 步进分解逻辑正确性
- [ ] 时间延迟是否充足（无抖动）
- [ ] 滑环连续旋转是否顺畅
- [ ] 大角度旋转后的定位精度
- [ ] 自瞄系统实际响应速度

---

## 参数调优指南

### 可调参数

#### 1. `MAX_STEP_ANGLE` (当前: 50°)

```python
# src/bot/gimbal.py 第 203 行
MAX_STEP_ANGLE = 50.0  # 可调范围: 45-54°
```

**调优建议**:
- 增大 → 减少步数，提高速度（风险：接近 ±55° 限制）
- 减小 → 增大安全余量，降低失败率（代价：速度变慢）

#### 2. 时间缓冲 (当前: 0.1s)

```python
# src/bot/gimbal.py 第 220、274 行
wait_time = abs(step) / vpitch + 0.1  # 可调范围: 0.05-0.3s
```

**调优建议**:
- 实测发现抖动/不稳定 → 增大至 0.15s 或 0.2s
- 实测稳定且响应偏慢 → 减小至 0.05s

### 调优流程

```
1. 硬件测试基准 (180° @ 90°/s)
   ↓
2. 观察现象:
   - 正常稳定 → 保持当前参数
   - 运动中断/卡顿 → 增大缓冲时间
   - 旋转角度不足 → 检查步进分解逻辑
   ↓
3. 边界测试:
   - 540° @ 180°/s (高速大角度)
   - 45° @ 90°/s (小角度直接发送)
   ↓
4. 自瞄集成测试:
   - 实际目标跟踪
   - 测量控制频率 (当前配置: 20Hz)
```

---

## 已知限制与风险

### 限制

1. **累积误差** (绝对角度模式)
   - 多次相对角度控制可能产生累积偏差
   - 建议定期使用 `set_gimbal_recenter()` 校准

2. **阻塞执行**
   - 大角度旋转耗时较长（540° ≈ 4s）
   - 必须在独立线程中调用（自瞄已满足）

3. **速度限制**
   - 下位机最大速度: 540°/s
   - 实际测试可能达不到理论值

### 风险

⚠️ **硬件损坏风险**:
- **前提**: 必须安装滑环
- **未安装滑环时**: 大角度旋转会撞击限位卡扣
- **建议**: 在代码中添加安全检查（待实现）

⚠️ **线缆缠绕风险**:
- 连续同向旋转 >720° 可能导致滑环线缆缠绕
- 建议添加旋转计数器（待实现）

---

## 未来改进方向

### 1. 非阻塞版本（异步）

```python
async def rotate_gimbal_async(pitch, yaw, vpitch, vyaw):
    """异步版本，不阻塞当前线程"""
    # 使用 asyncio 实现
```

**优势**: 允许在等待期间执行其他任务

### 2. 旋转方向优化

```python
# 当前: 目标 yaw=350° → 顺时针旋转 350°
# 优化: 目标 yaw=350° → 逆时针旋转 10°（更快）
def optimize_rotation_direction(target_yaw, current_yaw):
    """选择最短旋转路径"""
```

### 3. 安全检查机制

```python
# 在全局配置中添加
SLIP_RING_INSTALLED = True  # 滑环安装标志

# 在函数中检查
if not config.SLIP_RING_INSTALLED:
    raise RuntimeError("大角度旋转需要滑环支持！")
```

### 4. 旋转计数器

```python
# 记录累积旋转圈数
_rotation_counter = 0

def move_gimbal_360(...):
    global _rotation_counter
    _rotation_counter += yaw / 360
    if abs(_rotation_counter) > 2:
        LOG.warning("累积旋转 >2 圈，建议回中防止线缆缠绕")
```

---

## 总结

### 实现成果

✅ 成功实现 360° 无限旋转支持（相对角度 + 绝对角度）
✅ 集成到自瞄系统，突破 ±55° 限制
✅ 时间计算基于物理公式，经模拟验证正确
✅ 代码结构清晰，文档完善

### 待完成工作

- [ ] Raspberry Pi 硬件实测
- [ ] 时间缓冲参数调优
- [ ] 自瞄系统实际性能测试
- [ ] 安全检查机制实现
- [ ] 旋转计数器防缠绕

### 技术亮点

1. **算法优雅**: 角度分解 + 时间延迟，物理模型清晰
2. **向后兼容**: 保留旧版函数，不破坏现有代码
3. **可扩展性**: 独立函数设计，易于添加新功能
4. **工程实践**: 充分的文档、测试脚本、注释

---

**文档创建时间**: 2025年10月3日
**作者**: n1ghts4kura (with AI Assistant)
**版本**: v1.0
